---
title: "ハッシュテーブル"
linkTitle: "ハッシュテーブル"
weight: 8
date: 2017-01-04
description: ''
---

FaceやFIBの管理には独自実装のハッシュテーブル（Key-Value store）が使われています。`cef_lhash` 関連は[リストハッシュ](/docs/internals/listhash)を参照してください。

## 操作のための関数

### `cef_hash_tbl_create(uint32_t table_size)`
`table_size`個のレコードを持つハッシュテーブルを作成する。作成時に全体のメモリをごっそり確保（`malloc`）するので、csmgrdが4GB固定で必要なのもたぶんそれが原因。

### `cef`

## 構造

`CefT_Hash`

### ハッシュの計算
`cef_hash_number_create()`関数を参照。keyのMD5の12バイト目から4バイト（32bit）とってハッシュにする。

### 書き込み
`cef_hash_tbl_item_set()`関数。
keyからハッシュをつくって、`index = hash %  ht->elem_max(const)` とする。
1. indexにあるレコードが空（klen == 0）なら、そこに格納する
2. 空でないなら、そこから一つずつ歩いていって、空のレコード（またはhash, keyが同じレコード）が見つかったらそこに格納する
	1. ここで、削除済（klen == -1）のレコードが見つかったらそのうちの一つだけ場所をメモしておく
3. 最後（elem_max）まで歩いてもまだ見つからなかったら、先頭に戻ってまた歩く
	1. 削除済みも同様にメモしておく

keyが同じレコードがあるなら、レコードを新規作成するのではなくそれを書き換えるべき。よって削除済みで空になったレコードを見つけても、即座に入れることはしないでまずは探すということ。ただし、一度もデータが入ったことのない場所（klen == 0）より後ろに目的のレコードがあることはないので、klen == 0を見つけると新規のkeyであることが確定して書き込める（klen == 0 なレコードを飛ばして歩いていくことはない）。

例：

|index|0|1|2|3|4|5|
|-----|-|-|-|-|-|-|
|key|hogehoge|piyopiyo|hugahuga|foobar|NULL|NULL|
|klen|8|8|-1|6|0|0|
|elem|0xdeadbeef|0xdeadbeef|0xdeafbeef|NULL|NULL|NULL|

このテーブルで、2番目のkey `hugahuga` のレコードは削除済み。4番目と5番目のレコードが未書き込み。ここで、
- key `AAA`（ハッシュ値0）に値をセットしようとすると、0, 1, 2…と歩いて、書き込み先は2番目になる。
- key `foobar`（ハッシュ値1）に値をセットしようとすると、1, 2...と歩いて、途中で削除済みの2番目を発見するが一旦保留する。その次の3番目に同じkeyを発見するので、そこに書き込まれる。

### 読み込み
`cef_hash_tbl_item_get()`関数。削除済みを考慮しない点は書き込みと同じ。